#!/usr/bin/env python
# encoding: utf-8
r"""
Two-dimensional advection
=========================

Solve the two-dimensional advection equation

.. math::
    q_t + u q_x + v q_y = 0

Here q is a conserved quantity, and (u,v) is the velocity vector.
"""

import numpy as np
from clawpack import riemann
import logging

def qinit(state):
    """Set initial condition for q.
       Sample scalar equation with data that is piecewise constant with
       q = 1.0  if  0.1 < x < 0.6   and   0.1 < y < 0.6
           0.1  otherwise
    """
    X, Y = state.grid.p_centers
    state.q[0,:,:] = 0.9*(0.1<X)*(X<0.6)*(0.1<Y)*(Y<0.6) + 0.1
                

def generate_trajectory(config):
    #   use_petsc=False,outdir='./_output',solver_type='classic',
    #       dimensional_split=1,transverse_waves=0

    # Disable Logging files:
    logger = logging.getLogger('pyclaw')
    logger.setLevel(logging.CRITICAL)
    logging.disable(logging.CRITICAL)


    if config['use_petsc']:
        import clawpack.petclaw as pyclaw
    else:
        from clawpack import pyclaw

    if config['solver_type'] == 'classic':
        solver = pyclaw.ClawSolver2D(riemann.advection_2D)
        solver.dimensional_split = config['dimensional_split']
        solver.transverse_waves = config['transverse_waves']
        solver.limiters = pyclaw.limiters.tvd.vanleer
    elif config['solver_type'] == 'sharpclaw':
        solver = pyclaw.SharpClawSolver2D(riemann.advection_2D)

    #TODO: The boundary conditions will be specified by user in future 
    solver.bc_lower[0] = pyclaw.BC.periodic
    solver.bc_upper[0] = pyclaw.BC.periodic
    solver.bc_lower[1] = pyclaw.BC.periodic
    solver.bc_upper[1] = pyclaw.BC.periodic

    if not config['dimensional_split'] and not config['transverse_waves'] and config['solver_type'] == 'classic':
        solver.cfl_max = 0.5
        solver.cfl_desired = 0.45
    else:
        solver.cfl_max = 1.0
        solver.cfl_desired = 0.9

    # Domain:
    mx = config['x']['size'] 
    my = config['y']['size']
    x = pyclaw.Dimension(config['x']['domain'][0],config['x']['domain'][1],mx,name='x')
    y = pyclaw.Dimension(config['y']['domain'][0],config['y']['domain'][1],my,name='y')
    domain = pyclaw.Domain([x,y])

    num_eqn = 1
    state = pyclaw.State(domain,num_eqn)

    state.problem_data['u'] = 0.5 # TODO: Will be specified by user, Assume to be xy dependent
    state.problem_data['v'] = 1.0 # TODO: Will be specified by user, Assume to be xy dependent

    qinit(state) # TODO: Generated by Sampling from Gaussain Process

    claw = pyclaw.Controller()
    claw.num_output_times = config['num_output_steps']
    claw.tfinal = config['dt'] * config['num_output_steps'] 
    claw.solution = pyclaw.Solution(state,domain)
    claw.solver = solver
    claw.output_format = None
    claw.keep_copy = True
    claw.run()
    return claw
